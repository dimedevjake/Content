---
contributors: dimedevjake
---

## Generating SwiftData Model Classes using the Managed Object Model Editor assistant

- Start with a Core Data application.
- Navigate to the model file that contains information about the data and its organization.
- To generate SwiftData classes based on this model, go to the menu bar, select Editor, and click on Create SwiftData Code.
- Generate files for each of the entities.
- Now you should have SwiftData model classes for each entity. These Swift types should conform to the Model, and capture information for the entity as variables, including its attributes and its relationships to other entities.

## Complete SwiftData Adoption Process

- Ensure your Core Data model designs are supported in SwiftData, meaning for each entity defined in Core Data, there should be a corresponding model type with the same entity name and properties in SwiftData.
- Once the SwiftData model types are ready, delete the Core Data managed object model file that was used previously, and manage the model through these Swift files.
- Delete the Persistence file that previously set up the Core Data stack.
- Set up the modelContainer for the SwiftData stack. It's a modifier that ensures all windows in the group are configured to access the same persistent container.
- The modelContainer also creates and sets a default ModelContext in the environment, which is used to track changes to instances of the appâ€™s types.
- Replace the object creation and persistence methods in Core Data with those of SwiftData. For example, a new instance of Trip can be created and inserted into the model context.
- Use SwiftData's implicit save feature that triggers saves on UI lifecycle events and on a timer after the context is changed if possible, to save your data when the context changes.
- Replace Core Data fetch requests with SwiftData queries to fetch data.

### Creating a ModelContainer in SwiftUI
```swift                             
@main
struct TripsApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
        .modelContainer(
            for: [Trip.self, BucketListItem.self, LivingAccommodation.self]
        )
    }
}
```                        
### Object creation in Core Data
```swift 
@Environment(\.managedObjectContext) private var viewContext

let newTrip = Trip(context: viewContext)
newTrip.name = name
newTrip.destination = destination
newTrip.startDate = startDate
newTrip.endDate = endDate
```  
### Object creation in SwiftData
```swift 
@Environment(\.modelContext) private var modelContext

let trip = Trip(
    name: name,
    destination: destination,
    startDate: startDate,
    endDate: endDate
)

modelContext.insert(object: trip)
``` 
### Fetch with Query in SwiftData
```swift 
@Query(sort: \.startDate, order: .forward)

var trips: [Trip]
```                         
## Coexistence of Core Data and SwiftData

- If a full migration is not feasible, you can opt for coexistence where two separate persistent stacks, one for Core Data and one for SwiftData, communicate with the same persistent store.
- To set up both stacks to communicate with the same store, set the persistent store URL for the container description before loading the persistent store.
- Turn on persistent history tracking. SwiftData automatically turns it on, but Core Data does not.
- Namespace preexisting NSManagedObject-based entity subclasses or SwiftData classes so they do not collide.
- Keep the Core Data and SwiftData schemas in sync. New parts of the SwiftData schema must be materialized as an NSManagedObjectModel, and the two schemas cannot diverge.
- Keep track of the schema versions when incorporating coexistence. When working with multiple versions of the SwiftData model, ensure the changes are represented correctly.

### Setting store path and enabling persistent history tracking in Core Data
```swift 
let url = URL(fileURLWithPath: "/path/to/Trips.store")

if let description = container.persistentStoreDescriptions.first {
    description.url = url
    description.setOption(true as NSNumber, forKey: NSPersistentHistoryTrackingKey)
}
```
### Ensuring Core Data and SwiftData class names are unique
```swift 
class CDTrip: NSManagedObject {
    // ...
}


@Model final class Trip {
    // ...
}
```
